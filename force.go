package force

import (
	"context"
	"fmt"
	"os"
	"sync/atomic"
	"time"

	"github.com/gravitational/trace"
)

// SetupFunc is a plugin setup function
type SetupFunc func(ctx Group) error

// NewChannelFunc is a function that returns a new channel
type NewChannelFunc func(ctx Group) (Channel, error)

// Group represents a group of processes
type Group interface {
	// BroadcastEvents will broadcast events
	// to every process in a process group
	BroadcastEvents() chan<- Event

	// ExitEvent is set and returned when the group stop execution,
	// otherwise is nil, so callers should check for validity
	ExitEvent() ExitEvent

	// Context returns a process group context
	Context() context.Context

	// SetPlugin sets process group-local plugin
	// all setters and getters are thread safe
	SetPlugin(key interface{}, val interface{})

	// GetPlugin returns a process group plugin
	// all setters and getters are thread safe
	GetPlugin(key interface{}) (val interface{}, exists bool)

	// Logger returns a logger associated with this group
	Logger() Logger

	// IsDebug returns a global debug override
	IsDebug() bool
}

// Process is a process that is triggered by the event
type Process interface {
	Action
	// Name returns a process name
	Name() string
	// Channel returns a process channel
	Channel() Channel
	// Action returns a process action
	Action() Action
	// Events returns a channel that receives events
	Events() chan<- Event
	// Start is a non blocking call
	Start(ctx ExecutionContext) error
	// Runner returns a process group
	// this process belongs to
	Group() Group
	// Done signals that process has completed
	// handling channel events and exited
	Done() <-chan struct{}
	// String returns user friendly process name
	String() string
}

// Channel produces events
type Channel interface {
	// Start starts the process
	Start(ctx context.Context) error
	Events() <-chan Event
	Done() <-chan struct{}
}

// Action runs and returns a result
type Action interface {
	// Run returns result of the expression
	Run(ctx ExecutionContext) error
}

// ActionFunc is a wrapper around function
type ActionFunc func(ctx ExecutionContext) error

// Run returns a result after running
func (r ActionFunc) Run(ctx ExecutionContext) error {
	return r(ctx)
}

// Converter converts one value into another or returns error
type Converter interface {
	Convert(i interface{}) (interface{}, error)
}

// Spec is a process specification
type Spec struct {
	Name    string
	Watch   Channel
	Run     Action
	EventsC chan Event `code:"-"`
	// Group if set, will assign the process to a specific group,
	// otherwise, will be set to the default runner
	Group Group `code:"-"`
}

// processNumber is a helper number to generate
// meaningful process numbers in case if user did not specify one
var processNumber = int64(0)

func (s *Spec) CheckAndSetDefaults() error {
	if s.Name == "" {
		num := atomic.AddInt64(&processNumber, 1)
		host, _ := os.Hostname()
		s.Name = fmt.Sprintf("%v-%v", host, num)
	}
	if s.Watch == nil {
		oneshot, err := Oneshot()
		if err != nil {
			return trace.Wrap(err)
		}
		s.Watch = oneshot
	}
	if s.Run == nil {
		return trace.BadParameter("the Process needs Spec{Run:} parameter")
	}
	return nil
}

// Event is generated by channel
type Event interface {
	// AddMetadata adds metadada to the execution context
	AddMetadata(ctx ExecutionContext)
	// Created returns time when the event was originated in the system
	Created() time.Time
}

// SetError is a helper function that adds an error
// to the context
func SetError(ctx ExecutionContext, err error) {
	if err == nil {
		return
	}
	ctx.SetValue(KeyError, err)
}

// Error is a helper function that finds and returns
// an error
func Error(ctx ExecutionContext) error {
	out := ctx.Value(KeyError)
	if out == nil {
		return nil
	}
	err, ok := out.(error)
	if !ok {
		return nil
	}
	return err
}

// CloserFunc wraps function
// to create io.Closer compatible type
type CloserFunc func() error

// Close closes resources
func (fn CloserFunc) Close() error {
	return fn()
}
