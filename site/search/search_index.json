{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Force Force is an event processing and infrastructure automation framework. Makefiles create an easy way to build targets and projects. G files create an easy way to create event-driven workflows with multiple services combined together: Github to Docker builds, Webhooks to Kubernetes Deployments. Installation Current version is 0.0.7 . Install locally $ go install github.com/gravitational/force/tool/force Docker image docker pull gcr.io/kubeadm-167321/force:0.0.7 Local Docker Builds To use local force's ability to run builds, install runc 1.0.0-rc8","title":"Home"},{"location":"#force","text":"Force is an event processing and infrastructure automation framework. Makefiles create an easy way to build targets and projects. G files create an easy way to create event-driven workflows with multiple services combined together: Github to Docker builds, Webhooks to Kubernetes Deployments.","title":"Force"},{"location":"#installation","text":"Current version is 0.0.7 . Install locally $ go install github.com/gravitational/force/tool/force Docker image docker pull gcr.io/kubeadm-167321/force:0.0.7 Local Docker Builds To use local force's ability to run builds, install runc 1.0.0-rc8","title":"Installation"},{"location":"language/","text":"Processes, Channels and Actions force is a command line tool that processes G files. Every G file starts with a Process(Spec{}) section that specifies one or several Run actions triggered by events received by channel specified in the Watch section. Here is the process watch-and-build : Source file: ./examples/watch/G 0: Process(Spec{ 1: // Process name is used in the logs 2: Name: watch-and-build , 3: // Watch specifies channel generating events 4: Watch: Files( *.go ), 5: // Run specifies a sequence of actions 6: Run: Command( go install -mod=vendor -v github.com/gravitational/force/tool/force ), 7: }) Watch: Files(\"*.go\") specifies the channel that continuosly watches file changes matching the glob *.go and generates events. Every time the event is generated, the Command action runs the shell command go install -mod=vendor -v github.com/gravitational/force/tool/force . Syntax Force users Go language language grammar , however it does not fully implement golang language specification, however functions and function calls, variables and assignments use the same notation. Sequences Force can execute sequences of actions triggered by single event using func construct: Source file: ./examples/func/G 0: Process(Spec{ 1: Name: demo-functions , 2: Watch: Oneshot(), 3: Run: func(){ 4: // Logs message to log with info severity 5: Infof( Hello, world ) 6: Command(`echo hello, world! `) 7: }, 8: }) 9: Parallel Actions Force can run actions in parallel using Parallel functon: Source file: ./examples/parallel/G 0: Process(Spec{ 1: Name: demo-functions , 2: Watch: Oneshot(), 3: Run: func(){ 4: Parallel( 5: Infof( Hello, world ), 6: Command(`echo hello, world! `), 7: ) 8: }, 9: }) 10: Parallel launches all actions in parallel, collects the results. It succeeds when all actions succeed or fails if any of the actions fail. Variables G scripts support immutable variables (the ones that after declared, can't be changed). Source file: ./examples/cleanup/G 0: Process(Spec{ 1: Run: func(){ 2: dir := TempDir( , force ) 3: Infof( Created temp dir %v, who is going to clean it up? , dir) 4: }, 5: }) 6: At the moment, only string , bool and int variables are supported. Deferred actions In the previous examples, temporary directory was created but not removed. To execute actions at the end of the sequence (regardless of whether it was successfull or not) use the Defer action: Source file: ./examples/cleanup/cleanup.force 0: Process(Spec{ 1: Run: func(){ 2: dir := TempDir( , force ) 3: Defer(RemoveAll(dir)) 4: Infof( Created temp dir %v, who is going to clean it up? , dir) 5: }, 6: }) Lambda functions and includes Force supports simple lambda functions. Lambda function definition looks like a variable declaration. GlobalLog := func(message string) { Infof( this is a message: %v , message) } To define this or other global functions visible to the main force script, in file lib.force , write: Source file: ./examples/includes/lib.force 0: func() { 1: GlobalLog := func(message string) { 2: Infof( this is a message: %v , message) 3: } 4: } Reference the function in the G file: Source file: ./examples/includes/G 0: Process(Spec{ 1: Run: func(){ 2: GlobalLog( log this line ) 3: }, 4: }) Run the force using the --include directive: $ force --include=lib.force Exiting and Environment Most of the time force scripts are running continuosly, however sometimes it is helpful to exit, use Exit action. This action will cause force progam to exit with the success or error depending on whether the previous last action has failed or succeeded. Source file: ./examples/exit/G 0: Process(Spec{ 1: Run: func(){ 2: Defer(Exit()) 3: Infof( HOME: %v , ExpectEnv( HOME )) 4: }, 5: }) 6: Marshaling code Sometimes you need to run a part of the force script remotely - inside a kubernetes job, or using SSH call on the cloud server. Marshal action helps to marshal (and verify) the code to a string variable: Source file: ./examples/marshal/G 0: // This example demonstrates how to marshal 1: // parts of force script to string 2: Process(Spec{ 3: Name: marshal , 4: Run: func(){ 5: code := Marshal(func(){ 6: Infof( Hello, world! ) 7: }) 8: Infof( Code: %v , code) 9: }, 10: }) The code inside Marhsal function is not evaluated by default, however it is possible to pass variables to the remote call using Unquote : Source file: ./examples/marshal/unquote.force 0: // This example demonstrates how to marshal 1: // parts of force script to string using quoting 2: Process(Spec{ 3: Name: unquote , 4: Run: func(){ 5: localUser := ExpectEnv( USER ) 6: code := Marshal(func(){ 7: Infof( Caller: %v , Unquote(localUser)) 8: }) 9: Infof( Code: %v , code) 10: }, 11: }) The resulting code will evaluate the variable localUser and substitute it in the code: func(){ log.Infof( Caller: %v , bob ) } Here is a full example of sending code to another force process for execution: Source file: ./examples/marshal/rpc.force 0: Process(Spec{ 1: Name: rpc , 2: Run: func(){ 3: localUser := ExpectEnv( USER ) 4: code := Marshal(Process(Spec{ 5: Run: Infof( Caller: %v , Unquote(localUser)), 6: })) 7: Shell(Script{ 8: Env: Strings( 9: Sprintf( FORCE_SCRIPT=%v , code), 10: Sprintf( PATH=%v , ExpectEnv( PATH )), 11: ), 12: Command: force , 13: }) 14: }, 15: }) Plugins Force language is extended using plugins system. Special setup.force file could be placed alongside G file to setup a plugin: Source file: ./examples/plugins/setup.force 0: // Setup configures force plugins 1: Setup( 2: // Logging sets up logging plugin 3: log.Setup(log.Config{ 4: Level: debug , 5: Outputs: []log.Output{ 6: { 7: Type: stdout , 8: }, 9: }, 10: }), 11: )","title":"Language"},{"location":"language/#processes-channels-and-actions","text":"force is a command line tool that processes G files. Every G file starts with a Process(Spec{}) section that specifies one or several Run actions triggered by events received by channel specified in the Watch section. Here is the process watch-and-build : Source file: ./examples/watch/G 0: Process(Spec{ 1: // Process name is used in the logs 2: Name: watch-and-build , 3: // Watch specifies channel generating events 4: Watch: Files( *.go ), 5: // Run specifies a sequence of actions 6: Run: Command( go install -mod=vendor -v github.com/gravitational/force/tool/force ), 7: }) Watch: Files(\"*.go\") specifies the channel that continuosly watches file changes matching the glob *.go and generates events. Every time the event is generated, the Command action runs the shell command go install -mod=vendor -v github.com/gravitational/force/tool/force .","title":"Processes, Channels and Actions"},{"location":"language/#syntax","text":"Force users Go language language grammar , however it does not fully implement golang language specification, however functions and function calls, variables and assignments use the same notation.","title":"Syntax"},{"location":"language/#sequences","text":"Force can execute sequences of actions triggered by single event using func construct: Source file: ./examples/func/G 0: Process(Spec{ 1: Name: demo-functions , 2: Watch: Oneshot(), 3: Run: func(){ 4: // Logs message to log with info severity 5: Infof( Hello, world ) 6: Command(`echo hello, world! `) 7: }, 8: }) 9:","title":"Sequences"},{"location":"language/#parallel-actions","text":"Force can run actions in parallel using Parallel functon: Source file: ./examples/parallel/G 0: Process(Spec{ 1: Name: demo-functions , 2: Watch: Oneshot(), 3: Run: func(){ 4: Parallel( 5: Infof( Hello, world ), 6: Command(`echo hello, world! `), 7: ) 8: }, 9: }) 10: Parallel launches all actions in parallel, collects the results. It succeeds when all actions succeed or fails if any of the actions fail.","title":"Parallel Actions"},{"location":"language/#variables","text":"G scripts support immutable variables (the ones that after declared, can't be changed). Source file: ./examples/cleanup/G 0: Process(Spec{ 1: Run: func(){ 2: dir := TempDir( , force ) 3: Infof( Created temp dir %v, who is going to clean it up? , dir) 4: }, 5: }) 6: At the moment, only string , bool and int variables are supported.","title":"Variables"},{"location":"language/#deferred-actions","text":"In the previous examples, temporary directory was created but not removed. To execute actions at the end of the sequence (regardless of whether it was successfull or not) use the Defer action: Source file: ./examples/cleanup/cleanup.force 0: Process(Spec{ 1: Run: func(){ 2: dir := TempDir( , force ) 3: Defer(RemoveAll(dir)) 4: Infof( Created temp dir %v, who is going to clean it up? , dir) 5: }, 6: })","title":"Deferred actions"},{"location":"language/#lambda-functions-and-includes","text":"Force supports simple lambda functions. Lambda function definition looks like a variable declaration. GlobalLog := func(message string) { Infof( this is a message: %v , message) } To define this or other global functions visible to the main force script, in file lib.force , write: Source file: ./examples/includes/lib.force 0: func() { 1: GlobalLog := func(message string) { 2: Infof( this is a message: %v , message) 3: } 4: } Reference the function in the G file: Source file: ./examples/includes/G 0: Process(Spec{ 1: Run: func(){ 2: GlobalLog( log this line ) 3: }, 4: }) Run the force using the --include directive: $ force --include=lib.force","title":"Lambda functions and includes"},{"location":"language/#exiting-and-environment","text":"Most of the time force scripts are running continuosly, however sometimes it is helpful to exit, use Exit action. This action will cause force progam to exit with the success or error depending on whether the previous last action has failed or succeeded. Source file: ./examples/exit/G 0: Process(Spec{ 1: Run: func(){ 2: Defer(Exit()) 3: Infof( HOME: %v , ExpectEnv( HOME )) 4: }, 5: }) 6:","title":"Exiting and Environment"},{"location":"language/#marshaling-code","text":"Sometimes you need to run a part of the force script remotely - inside a kubernetes job, or using SSH call on the cloud server. Marshal action helps to marshal (and verify) the code to a string variable: Source file: ./examples/marshal/G 0: // This example demonstrates how to marshal 1: // parts of force script to string 2: Process(Spec{ 3: Name: marshal , 4: Run: func(){ 5: code := Marshal(func(){ 6: Infof( Hello, world! ) 7: }) 8: Infof( Code: %v , code) 9: }, 10: }) The code inside Marhsal function is not evaluated by default, however it is possible to pass variables to the remote call using Unquote : Source file: ./examples/marshal/unquote.force 0: // This example demonstrates how to marshal 1: // parts of force script to string using quoting 2: Process(Spec{ 3: Name: unquote , 4: Run: func(){ 5: localUser := ExpectEnv( USER ) 6: code := Marshal(func(){ 7: Infof( Caller: %v , Unquote(localUser)) 8: }) 9: Infof( Code: %v , code) 10: }, 11: }) The resulting code will evaluate the variable localUser and substitute it in the code: func(){ log.Infof( Caller: %v , bob ) } Here is a full example of sending code to another force process for execution: Source file: ./examples/marshal/rpc.force 0: Process(Spec{ 1: Name: rpc , 2: Run: func(){ 3: localUser := ExpectEnv( USER ) 4: code := Marshal(Process(Spec{ 5: Run: Infof( Caller: %v , Unquote(localUser)), 6: })) 7: Shell(Script{ 8: Env: Strings( 9: Sprintf( FORCE_SCRIPT=%v , code), 10: Sprintf( PATH=%v , ExpectEnv( PATH )), 11: ), 12: Command: force , 13: }) 14: }, 15: })","title":"Marshaling code"},{"location":"language/#plugins","text":"Force language is extended using plugins system. Special setup.force file could be placed alongside G file to setup a plugin: Source file: ./examples/plugins/setup.force 0: // Setup configures force plugins 1: Setup( 2: // Logging sets up logging plugin 3: log.Setup(log.Config{ 4: Level: debug , 5: Outputs: []log.Output{ 6: { 7: Type: stdout , 8: }, 9: }, 10: }), 11: )","title":"Plugins"},{"location":"quickstart/","text":"Quickstart Hello, world! force is a command line tool that processes G files. Create your first Hello, world! file named G : Process(Spec{ Run: Command(`echo hello, world! `), }) To process the file, run force : $ force INFO Process planet-1 triggered by Oneshot(time=2019-09-15 23:37:37.181326936 +0000 UTC) INFO [PLANET-1] hello, world! id:48c69283 proc:planet-1 INFO [PLANET-1] Process planet-1 completed successfully in 1.086956ms. id:48c69283 proc:planet-1 To exit force type Ctrl-C . Every G file starts with a Process(Spec{}) section that specifies one or several Run actions triggered by events received by channels. Our example did not specify any event, so force used a default Oneshot() channel. The example above is equivalent to: Process(Spec{ Watch: Oneshot(), Run: Command(`echo hello, world! `), })","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Hello, world! force is a command line tool that processes G files. Create your first Hello, world! file named G : Process(Spec{ Run: Command(`echo hello, world! `), }) To process the file, run force : $ force INFO Process planet-1 triggered by Oneshot(time=2019-09-15 23:37:37.181326936 +0000 UTC) INFO [PLANET-1] hello, world! id:48c69283 proc:planet-1 INFO [PLANET-1] Process planet-1 completed successfully in 1.086956ms. id:48c69283 proc:planet-1 To exit force type Ctrl-C . Every G file starts with a Process(Spec{}) section that specifies one or several Run actions triggered by events received by channels. Our example did not specify any event, so force used a default Oneshot() channel. The example above is equivalent to: Process(Spec{ Watch: Oneshot(), Run: Command(`echo hello, world! `), })","title":"Quickstart"}]}